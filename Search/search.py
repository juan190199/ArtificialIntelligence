import utilclass SearchProblem:    """        This class outlines the structure of a search problem, but doesn't implement        any of the methods (in object-oriented terminology: an abstract class).    """    def getStartState(self):        """        Returns the start state for the search problem.        """    def isGoalState(self, state):        """        state: Search state        Returns True if and only if the state is a valid goal state.        """    def getSuccessors(self, state):        """        state: Search state        For a given state, this should return a list of triples, (successor,        action, stepCost), where 'successor' is a successor to the current        state, 'action' is the action required to get there, and 'stepCost' is        the incremental cost of expanding to that successor.        """    def getCostOfActions(self, actions):        """        actions: A list of actions to take        This method returns the total cost of a particular sequence of actions.        The sequence must be composed of legal moves.        """#     TODO: Implement general search algorithm for bfs and dfs with help of data structures in util.#      The algorithm should be a graph searchdef generalSearch(problem, fn):    dataStructure = {'dfs': util.Stack(), 'bfs': util.Queue()}    root = getStartState()    try:        visited = set()        frontier = dataStructure[fn]        frontier.push((root, [], 0))        while not frontier.isEmpty():            location, path, cost = frontier.pop()            if problem.isGoalState()                return path            if location not in visited:                visited.add(location)                for successor, action, stepCost in problem.getSuccessors(location):                    if successor not in visited:                        frontier.push((successor, path + [action], stepCost))        return []def breadthFirstSearch(problem):    """Search the shallowest nodes in the search tree first."""    generalSearch(problem, fn=bfs)def depthFirstSearch(problem):    """Search the deepest nodes in the search tree first."""    generalSearchProblem(problem, fn=dfs)# Abbreviationsbfs = breadthFirstSearchdfs = depthFirstSearchastar = aStarSearchucs = uniformCostSearch