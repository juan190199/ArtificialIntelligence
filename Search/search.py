import utilclass SearchProblem:    """        This class outlines the structure of a search problem, but doesn't implement        any of the methods (in object-oriented terminology: an abstract class).    """    def getStartState(self):        """        Returns the start state for the search problem.        """    def isGoalState(self, state):        """        state: Search state        Returns True if and only if the state is a valid goal state.        """    def getSuccessors(self, state):        """        state: Search state        For a given state, this should return a list of triples, (successor,        action, stepCost), where 'successor' is a successor to the current        state, 'action' is the action required to get there, and 'stepCost' is        the incremental cost of expanding to that successor.        """    def getCostOfActions(self, actions):        """        actions: A list of actions to take        This method returns the total cost of a particular sequence of actions.        The sequence must be composed of legal moves.        """#     TODO: Implement general search algorithm for bfs and dfs with help of data structures in util.#      The algorithm should be a graph searchdef generalSearch(problem, fn):    dataStructure = {'dfs': util.Stack(), 'bfs': util.Queue()}    root = getStartState()    try:        visited = set()        frontier = dataStructure[fn]        frontier.push((root, [], 0))        while not frontier.isEmpty():            location, path, cost = frontier.pop()            if problem.isGoalState()                return path            if location not in visited:                visited.add(location)                for successor, action, stepCost in problem.getSuccessors(location):                    if successor not in visited:                        frontier.push((successor, path + [action], stepCost))        return []    except Exception as e:        print(e)def breadthFirstSearch(problem):    """Search the shallowest nodes in the search tree first."""    generalSearch(problem, fn=bfs)def depthFirstSearch(problem):    """Search the deepest nodes in the search tree first."""    generalSearch(problem, fn=dfs)def uniformCostSearch(problem):    """Search the node of least total cost first."""    root = getStartState()    try:        visited = set()        frontier = util.PriorityQueue()        frontier.push((root, [], 0), 0) # frontier.push(state, priority)        while not frontier.isEmpty():            location, path, cost = frontier.pop()            if problem.isGoalState():                return path            if location not in visited:                visited.add(location)                for successor, action, stepCost in problem.getSuccessors(location)                    if successor not in visited:                        frontier.push((successor, path + [action], stepCost + cost), stepCost + cost)        return[]    except Exception as e:        print(e)def nullHeuristic(state, problem=None):    """    A heuristic function estimates the cost from the current state to the nearest    goal in the provided SearchProblem.  This heuristic is trivial.    """    return 0def aStarSearch(problem, heuristic=nullHeuristic()):    """Search the node that has the lowest combined cost and heuristic first."""    pass    root = problem.getStartState()    try:        visited = set()        frontier = util.PriorityQueue()        frontier.push((root, [], 0), 0)        while not frontier.isEmpty():            location, path, cost = frontier.pop()            if problem.isGoalState():                return path            if location not in visited:                visited.add(location)                for successor, action, stepCost in problem.getSuccessors(location)                    if successor not in visited:                        backwardCost = stepCost + cost                        forwardCost = heuristic(successor, problem)                        functionTotalCost = backwardCost + forwardCost                        frontier.push((successor, path + [action], backwardCost), functionTotalCost)        return[]    except Exception as e:        print(e)        # Abbreviationsbfs = breadthFirstSearchdfs = depthFirstSearchastar = aStarSearchucs = uniformCostSearch